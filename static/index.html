<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width"><link rel="icon" href="data:">
<title>高専プロコン掲示板#35</title>

<link rel="stylesheet" href="https://unpkg.com/sakura.css/css/sakura.css" type="text/css">
</head>
<body>

<h1><a href=./>高専プロコン掲示板#35</a></h1>

<input id=infilter placeholder="フィルター">
<div id=container></div>

<footer>
  <div>DATA: CC BY <a href=https://github.com/codeforkosen/kosen-opendata/blob/main/data/procon/procon2024.csv>高専プロコン2024オープンデータ</a> by Code for KOSEN</div>
  <div>App: MIT License <a href=https://codeforkosen.github.io/>Code for KOSEN</a></div>
  <div>Trust: <a href=https://github.com/code4fukui/Ed25519>Ed25519</a></div>
  <div><a href=https://github.com/codeforkosen/proconbbs>src on GitHub</a></div>
  <script type="module" src="https://code4fukui.github.io/qr-code/qr-code.js"></script>
  <qr-code></qr-code>
</footer>
</body>

<script type="module">
import { fetchJSON } from "https://js.sabae.cc/fetchJSON.js";
import { enc } from "https://js.sabae.cc/enc.js";
import { DateTime } from "https://code4fukui.github.io/day-es/DateTime.js";
import { TrustData } from "https://code4fukui.github.io/DataWithTrust/TrustData.js";
import { Base16 } from "https://code4fukui.github.io/Base16/Base16.js";
import { Ed25519 } from "https://code4fukui.github.io/Ed25519/Ed25519.js";
import { fix0 } from "https://js.sabae.cc/fix0.js";
import { CSV } from "https://js.sabae.cc/CSV.js";

const createYouTube = (link) => {
  const n = link.match(/v=(.+)/);
  console.log(link, n);
  const id = n[1];
  const iframe = document.createElement("iframe");
  iframe.src = "https://www.youtube.com/embed/" + id;
  iframe.title = "YouTube video player";
  iframe.frameborder = "0";
  iframe.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture";
  iframe.allowfullscreen = "allowfullscreen";
  return iframe;
};

const sign = (user, text) => {
  const message = new TextEncoder().encode(text);
  const signature = Ed25519.sign({ privateKey: user.secret, message, encodeing: "binary" });
  //const chk = Ed25519.verify({ signature, publicKey: user.did, message, encoding: "binary" });
  //console.log(chk);
  return signature;
};

const getUser = () => {
  const did = localStorage.getItem("did");
  const secret = localStorage.getItem("secret");
  const nickname = localStorage.getItem("nickname");
  if (did && secret) {
    return { did: Base16.decode(did), secret: Base16.decode(secret), nickname };
  }
  {
    const user = TrustData.createUser();
    localStorage.setItem("did", Base16.encode(user.did));
    localStorage.setItem("secret", Base16.encode(user.secret));
    user.nickname = prompt("ニックネームを入力ください") || "noname";
    localStorage.setItem("nickname", user.nickname);
    return user;
  }
};

const url = "https://codeforkosen.github.io/kosen-opendata/data/procon/procon2024.csv";
const data = await CSV.fetchJSON(url);

const prize = [];
/*
{
  const url = "https://codeforkosen.github.io/kosen-opendata/data/procon/procon2023_prize.csv";
  const data = await CSV.fetchJSON(url);
  data.forEach(d => prize.push(d));
}
*/

const bbsdata = await fetchJSON("api/list");

const cr = (tag, p) => {
  const c = document.createElement(tag);
  if (p) {
    p.appendChild(c);
  }
  return c;
};
const pickid = decodeURIComponent(location.hash.substring(1));

if (pickid) {
  infilter.style.display = "none";
}

const deepContains = (obj, keyword) => {
  for (const name in obj) {
    const o = obj[name];
    if (typeof o == "string") {
      if (o.indexOf(keyword) != -1) {
        return true;
      }
    } else if (Array.isArray(o)) {
      for (const a of o) {
        if (deepContains(a, keyword)) {
          return true;
        }
      }
    } else if (typeof o == "object") {
      if (deepContains(o, keyword)) {
        return true;
      }
    }
  }
  return false;
};

const show = async () => {
  container.innerHTML = "";
  const filter = infilter.value;
  console.log(pickid);
  for (const t of data) {
    if (pickid && t.type + t.num != pickid) {
      continue;
    }
    const bbs = bbsdata.find(o => o.type == t.type && o.num == t.num);
    t.items = bbs ? bbs.items || [] : [];

    if (filter && !deepContains(t, filter)) {
      continue;
    }

    const topic = cr("div", container);
    topic.className = "topic";
    const name = cr("div", topic);
    const items = t.items;
    name.innerHTML = `<a href="./#${t.type}${t.num}" target=_blank>${t.type.substring(0, 2)}-${t.num}</a>: ${t.title}${t.description ? " - " + t.description : ""} by ${t.kosen} (${items.length}件${t.prize ? " / " + t.prize : ""})`;
    const comments = cr("div", topic);
    comments.style.display = pickid ? "block" : "none";
    comments.className = "comments";
    const addComment = (d, parent) => {
      const div = cr("div", parent);
      div.className = "bbsitem";
      div.innerHTML = `<span class=date>${enc(new DateTime(d.date).toStringMin().substring(5))}</span>
      by <span class=name title=${d.did}>${d.nickname}</span>
        <div class=body>${enc(d.body || "")}</div>`;
      return div;
    };
    items.forEach(d => addComment(d, comments));

    const combox = cr("div", comments);
    const inp = cr("input", combox);
    const btn = cr("button", combox);
    btn.textContent = "送信";

    name.onclick = () => {
      if (comments.style.display == "none") {
        comments.style.display = "block";
      } else {
        comments.style.display = "none";
      }
    };

    const write = async (item) => {
      if (await fetchJSON("api/add", item) != "ok") {
        alert("書き込みに失敗しました");
        return false;
      }
      return true;
    };
    btn.onclick = async () => {
      const user = getUser();
      const comment = inp.value;
      const item = {
        type: t.type,
        num: t.num,
        did: Base16.encode(user.did),
        nickname: user.nickname,
        body: comment,
        date: new DateTime().toString(),
      };
      item.sign = Base16.encode(sign(user, item.body + "\n" + item.date));
      if (await write(item)) {
        inp.value = "";
        const add = addComment(item, null);
        comments.insertBefore(add, combox);
      }
    };
    const d = t;
    // photo
    if (d.photo) {
      const img = new Image();
      img.loading = "lazy";
      img.src = d.photo;
      comments.appendChild(img);
    }
    // hacku_tweet
    if (d.hacku) {
      const a = cr("a", comments); // todo: twitter embded
      a.href = d.hacku;
      a.textContent = "Hack U ポスト";
      comments.appendChild(a);
      cr("br", comments);
    }
    // hacku_interview
    if (d.hacku_interview) {
      //const youtube = createYouTube(d.hacku_interview); // todo: seek
      //comments.appendChild(youtube);
      const a = cr("a", comments);
      a.href = d.hacku_interview;
      a.textContent = "Hack U インタビュー動画";
      console.log(d.hacku_interview);
      comments.appendChild(a);
      cr("br", comments);
    }
    cr("br", comments);
    // youtube
    if (d.youtube) {
      const youtube = createYouTube(d.youtube);
      comments.appendChild(youtube);
    }
    // poster image 
    if (d.poster) {
      const img = new Image();
      img.loading = "lazy";
      img.src = d.poster;
      comments.appendChild(img);
    }
    // prize
    if (d.prize) {
      const ps = d.prize.split(",");
      for (const p of ps) {
        const div = cr("div", comments);
        const pr = prize.find(i => i.prize == p);
        if (pr) {
          div.textContent = p + " (副賞: " + pr.sup_prize + ")";
        } else {
          div.textContent = p;
        }
        comments.appendChild(div);
      }
    }
  }
};

show();
infilter.onchange = () => show();

</script>

<style>
body {
  max-width: 50em;
}
h1 a {
  text-decoration: none;
}
.topic {
  margin-bottom: 16px;
}
.comments {
  padding-left: 1em;
  margin-bottom: 8px;
}
.bbsitem {
  padding-bottom: 2px;
  border-bottom: 1px solid gray;
  margin-bottom: 8px;
}
.bbsitem div {
  display: inline-block;
  margin-left: 1em;
}
.comments input {
  width: 80%;
  font-size: 16px;
}
.bbsitem img {
  width: 90vw;
  margin-top: .5em;
}
iframe {
  width: 100%;
  aspect-ratio: 16 / 9;
}
#infilter {
  width: 100%;
}
</style>
  
</html>
